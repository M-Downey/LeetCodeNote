### [741. 摘樱桃](https://leetcode.cn/problems/cherry-pickup/)

- 困难

一个N x N的网格`(grid)` 代表了一块樱桃地，每个格子由以下三种数字的一种来表示：

- 0 表示这个格子是空的，所以你可以穿过它。
- 1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。
- -1 表示这个格子里有荆棘，挡着你的路。

你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃：

- 从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；
- 当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；
- 当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）；
- 如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。

**示例 1:**

```
输入: grid =
[[0, 1, -1],
 [1, 0, -1],
 [1, 1,  1]]
输出: 5
解释： 
玩家从（0,0）点出发，经过了向下走，向下走，向右走，向右走，到达了点(2, 2)。
在这趟单程中，总共摘到了4颗樱桃，矩阵变成了[[0,1,-1],[0,0,-1],[0,0,0]]。
接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了1颗樱桃。
在旅程中，总共摘到了5颗樱桃，这是可以摘到的最大值了。
```

**说明:**

- `grid` 是一个 `N` * `N` 的二维数组，N的取值范围是`1 <= N <= 50`。
- 每一个 `grid[i][j]` 都是集合 `{-1, 0, 1}`其中的一个数。
- 以保证起点 `grid[0][0]` 和终点 `grid[N-1][N-1]` 的值都不会是 -1。

**解法一：DP**

[宫水三叶题解](https://leetcode.cn/problems/cherry-pickup/solution/by-ac_oier-pz7i/)

```python
class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        n = len(grid)
        dp = [[[float('-inf')] * (n + 1) for _ in range(n + 1)] for _ in range(2 * n + 1)]
        # 从 (0, 0) 走到表格中左上角 (1, 1)
        dp[2][1][1] = grid[0][0]
        # dp[k][i][j] 代表当前总共走了 k 步(每个人)，两人分别在第 i 和 j 行时，最多的得分
        # 前驱状态有 dp[k - 1][i - 1][j], dp[k - 1][i][j - 1]
        #           dp[k - 1][i - 1][j - 1], dp[k - 1][i][j] 取最大
        # dp[k][j][j] = max(a, b, c, d) + A + B(if i1 != i2)
        # 返回 dp[2 * n][n][n]
        for k in range(3, 2 * n + 1):
            for i1 in range(1, n + 1):
                for i2 in range(1, n + 1):
                    j1, j2 = k - i1, k - i2
                    # 如果得到的列不是 1-n 就继续
                    if j1 <= 0 or j1 > n or j2 <= 0 or j2 > n:
                        continue
                    A = grid[i1 - 1][j1 - 1]
                    B = grid[i2 - 1][j2 - 1]
                    # 有荆棘，不用改变 dp 的值，继续
                    if A == -1 or B == -1:
                        continue
                    # 少走一步，可能是少走了一行或一列，2*2=4种结果
                    a = dp[k - 1][i1 - 1][i2]
                    b = dp[k - 1][i1][i2 - 1]
                    c = dp[k - 1][i1 - 1][i2 - 1]
                    d = dp[k - 1][i1][i2]
                    tmp = max(a, b, c, d) + A
                    # 如果当前不是同一格，那么加上当前格的值
                    if i1 != i2:
                        tmp += B
                    dp[k][i1][i2] = tmp
        # print(dp)
        ans = dp[2 * n][n][n]
        return 0 if ans <= 0 else ans
```

