### [856. 括号的分数](https://leetcode.cn/problems/score-of-parentheses/)

- 中等

给定一个平衡括号字符串 `S`，按下述规则计算该字符串的分数：

- `()` 得 1 分。
- `AB` 得 `A + B` 分，其中 A 和 B 是平衡括号字符串。
- `(A)` 得 `2 * A` 分，其中 A 是平衡括号字符串。

**示例 1：**

```
输入： "()"
输出： 1
```

**示例 2：**

```
输入： "(())"
输出： 2
```

**示例 3：**

```
输入： "()()"
输出： 2
```

**示例 4：**

```
输入： "(()(()))"
输出： 6
```

**提示：**

1. `S` 是平衡括号字符串，且只含有 `(` 和 `)` 。
2. `2 <= S.length <= 50`

**解法一：栈**

用栈保存遍历到当前字符时，所有平衡括号字符串的分数

遍历字符串，计算当前平衡字符串的分数并存入栈中

初始化将答案 0 放入栈中，从前往后处理整个 s，当遇到 ( 则存入一个占位数值 0，遇到 ) 取出栈顶元素 cur，根据栈顶元素数值值分情况讨论：

- 栈顶元素 $cur = 0$，即当前的 ) 的前一元素即是 ( ，根据 () 得一分的规则可知，我们本次操作得到的分值为 1；
- 栈顶元素 $cur \neq 0$ ，即当前 ) 与其匹配的 ( 中间相隔了其他字符，根据 (A) 的得分规则，此时可知得分为 $cur \times 2$；
  将两者结合可统一为 $\max(cur \times 2, 1)$。

由于我们每次遇到 ) 时，都将最近一次操作计算出来。而再前面无论是 ) 还是 ( 我们都可以归结到 X() 的相邻项累加规则，将其新得分累加到栈顶元素上，其中 ( 仍采用累加规则，则利用我们将 ( 定义为 0 的设定。

```python
class Solution:
    def scoreOfParentheses(self, s: str) -> int:
        stk = [0]
        for c in s:
            if c == '(':
                stk.append(0)
            else:
                cur = stk.pop()
                stk.append(stk.pop() + max(cur * 2, 1))
        return stk[-1]
```

